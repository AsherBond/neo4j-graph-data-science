= Aura Graph Analytics Serverless

Aura Graph Analytics Serverless is an on-demand ephemeral compute environment for running GDS workloads.
Each compute unit is called a _GDS Session_.
It is offered as part of link:https://neo4j.com/docs/aura/graph-analytics/[Neo4j Aura], a fast, scalable, always-on, fully automated cloud graph platform.

There are three types of GDS Sessions:

* *Attached*: the data source is a Neo4j AuraDB instance.
* *Self-managed*: the data source is a self-managed Neo4j DBMS.
* *Standalone*: the data source is not based on Neo4j.

We call the process of populating the session with data a _remote projection_.
Once populated, a GDS Session can run GDS workloads, such as algorithms and machine learning models.
The results from these computations can be written back to the original source, using _remote write-back_ in the Attached and Self-managed types.


== Primary API surfaces

GDS Sessions do not require any installation to a Neo4j DBMS.
Instead, a GDS Session is started on-demand to perform GDS computations.
There are two primary APIs for working with GDS Sessions: the GDS Python Client and the GDS Session Cypher API.


[[gds-python-client]]
=== GDS Python Client

Using the client, it is possible to perform all operations on a GDS Session.
For a comprehensive API overview including examples and tutorials, see link:https://neo4j.com/docs/graph-data-science-client/current/graph-analytics-serverless/[the GDS Python Client manual].

In particular, the GDS Python Client allows you to:

- link:https://neo4j.com/docs/graph-data-science-client/current/graph-analytics-serverless/#_creating_a_gds_session[Create GDS Sessions]
- link:https://neo4j.com/docs/graph-data-science-client/current/graph-analytics-serverless/#_projecting_graphs_into_a_gds_session[Project graphs into GDS sessions]

- link:https://neo4j.com/docs/graph-data-science-client/current/graph-analytics-serverless/#_running_algorithms[Run algorithms and machine learning operations]
- link:https://neo4j.com/docs/graph-data-science-client/current/graph-analytics-serverless/#_remote_write_back[If sourced from a Neo4j DBMS, write back results]
- link:https://neo4j.com/docs/graph-data-science-client/current/graph-analytics-serverless/#_listing_gds_sessions[List sessions]
- link:https://neo4j.com/docs/graph-data-science-client/current/graph-analytics-serverless/#_deleting_a_gds_session[Delete sessions]

A good place to start are the Tutorials:

- link:https://neo4j.com/docs/graph-data-science-client/current/tutorials/graph-analytics-serverless/[GDS Sessions for AuraDB]
- link:https://neo4j.com/docs/graph-data-science-client/current/tutorials/graph-analytics-serverless-self-managed/[GDS Sessions for Self-Managed Neo4j DB]


=== GDS Session Cypher API

This manual covers all aspects of the GDS Session Cypher API.
The Cypher API supports remote projections, calling algorithms and machine learning operations, and remote write back to the AuraDB instance.
It is currently offered only for AuraDB and is used from within a Cypher query context, such as Query in the Aura Console.

In the following sections we will focus only on the GDS Session Cypher API, assuming that it is used from an AuraDB instance.


== Session configuration

=== Session size

When the graph projection is requested, a mandatory `memory` parameter must be specified, indicating the size of the session.
The size of the session is the maximum amount of memory allocated to the analytical process.
A larger size means faster runtime and an ability to process larger volumes of data, but it will also be more expensive.

Supported values are: `4GB`, `8GB`, `16GB`, `24GB`, `32GB`, `48GB`, `64GB`, `96GB`, `128GB`, `192GB`, `256GB`, `384GB`, and `512GB`.

[NOTE]
Session maximum size can be configured for your Aura organization.
Check with your organization administrator what your maximum size is.


=== AuraDB source instance limitations

The GDS Session Cypher API is available only for AuraDB instances in the Business Critical or Virtual Dedicated Cloud plans.
Depending on which plan is used, different limitations apply.
See link:https://neo4j.com/docs/aura/graph-analytics/#_comparison[Graph analytics in Aura] for a comparison view.


=== Session expiration and deletion

When the graph projection is requested, an optional `ttl` parameter can be configured, which specifies how quickly an inactive session will expire.
The default value for `ttl` is 1 hour and the maximum allowed value is 7 days.
An expired session cannot be used to run workloads, does not cost anything, and will be deleted automatically after 7 days.
It can also be deleted through the Aura Console UI.


==== Maximum lifetime

A session can never be kept active for more than 7 days.
Even if the session does not expire due to inactivity, it will still expire 7 days after its creation.
This is a hard limit and cannot be changed.


== Session management and lifecycle

In the Cypher API, sessions can be managed in two different ways:
 . <<implicit-session-management,Implicitly>>
 . <<explicit-session-management,Explicitly>>

The implicit session management is the default way of working with GDS Sessions in the Cypher API.
After a session is created and the graph is projected, both options are identical in the use of GDS algorithms.

[[implicit-session-management]]
=== Implicit session management

In the implicit managed sessions option, a GDS Session is created automatically when a remote projection is run, and deleted when the graph is dropped.
Sessions can still be listed and dropped via the corresponding <<session-management-procedures,session management procedures>>.
In the case where additional graphs are projected into the same session, for example via xref:management-ops/graph-creation/graph-filter.adoc[graph filtering], the session will not be deleted until all graphs are dropped.


[[explicit-session-management]]
=== Explicit session management

In the explicit managed sessions option, a GDS Session has to be created explicitly before executing any projection using the <<session-create-procedure,`gds.session.getOrCreate`>> procedure. To project a graph onto the created GDS Session, the `id` column of the <<session-create-procedure-results,procedure result table>> must be passed as the `gds.graph.project` functions's `sessionId` xref:management-ops/graph-creation/graph-project-cypher-projection.adoc#graph-project-cypher-projection-syntax-configuration[configuration parameter].


[[session-management-procedures]]
== Session management procedures

The session management procedures allow to explicitly manage GDS Sessions without having to project a graph. They allow to list and delete existing sessions, or create new sessions and are designed to mimic the workflow of the <<gds-python-client, GDS Python Client>>.


[[session-create-procedure]]
=== Creating sessions

Calling the `gds.session.getOrCreate` procedure will trigger the creation of a GDS Session based on the specified procedure parameters if no other session with the given name an configuration already exists. If such a session already exists, that session will be returned instead.


==== Syntax

[source, cypher]
----
CALL gds.session.getOrCreate(
  sessionName: String,
  memory: String,
  ttl: Duration
  cloudLocation: Map
) YIELD
  id: String,
  name: String,
  auraInstanceId: String,
  memory: String,
  status: String,
  creationTime: Datetime,
  host: String,
  expiryDate: Datetime,
  ttl: TemporalAmount,
  errorMessage: String
----

.Parameters
[opts="header",cols="1,1,1,4"]
|===
| Name          | Type      | Optional | Description
| sessionName   | String    | no       | The name of the GDS Session to create or return.
| memory        | String    | no       | The size of the GDS Session, e.g. `4GB`, `8GB`, etc.
| ttl           | Duration  | yes      | The time to live of the GDS Session when no activity is recorded, e.g. `duration({days: 1})`, `duration({hours: 12})`, etc. The default value is 2 days.
|===

[[session-create-procedure-results]]
.Results
[opts="header",cols="3m,1,6"]
|===
| Name                   | Type     | Description
| id                     | String   | The unique identifier of the GDS Session.
| name                   | String   | The name of the GDS Session.
| auraInstanceId         | String   | The Aura instance ID to which the GDS Session is attached to.
| memory                 | String   | The size of the GDS Session, e.g. `4GB`, `8GB`, etc.
| status                 | String   | The status of the GDS Session, e.g. `Creating`, `Ready`, `Expired`, etc.
| creationTime           | Datetime | The time when the GDS Session was created.
| host                   | String   | The public host address of the GDS Session.
| expiryDate             | Datetime | The time when the GDS Session will definitely expire.
| ttl                    | TemporalAmount | The time that is left until the GDS Session expires due to inactivity.
| errorMessage           | String   | The error message, if the GDS Session could not be created or is in an unhealthy state.
|===


=== Listing sessions

Calling the `gds.session.list` procedure will return GDS Sessions that are available to the current aura user.


==== Syntax

[source, cypher]
----
CALL gds.session.list(
  projectId: String,
  filterAuraInstanceId: boolean
) YIELD
  id: String,
  name: String,
  auraInstanceId: String,
  memory: String,
  status: String,
  creationTime: Datetime,
  host: String,
  expiryDate: Datetime,
  ttl: TemporalAmount,
  errorMessage: String
----

.Parameters
[opts="header",cols="1,1,1,1,4"]
|===
| Name               | Type      | Optional | Default | Description
| projectId          | String    | yes      | ""      | The ID of the project to which the GDS Sessions belong. If not specified, all sessions of the aura user are returned.
| filterAuraInstance | String    | yes      | false   | If set to `true`, only sessions that are attached to current Aura instance are returned. If not specified, all sessions of the aura user are returned.
|===

.Results
[opts="header",cols="3m,1,6"]
|===
| Name                   | Type     | Description
| id                     | String   | The unique identifier of the GDS Session.
| name                   | String   | The name of the GDS Session.
| auraInstanceId         | String   | The Aura instance ID to which the GDS Session is attached to.
| memory                 | String   | The size of the GDS Session, e.g. `4GB`, `8GB`, etc.
| status                 | String   | The status of the GDS Session, e.g. `Creating`, `Ready`, `Expired`, etc.
| creationTime           | Datetime | The time when the GDS Session was created.
| host                   | String   | The public host address of the GDS Session.
| expiryDate             | Datetime | The time when the GDS Session will definitely expire.
| ttl                    | TemporalAmount | The time that is left until the GDS Session expires due to inactivity.
| errorMessage           | String   | The error message, if the GDS Session could not be created or is in an unhealthy state.
|===


=== Deleting sessions

Calling the `gds.session.delete` procedure will delete a GDS Session with the given ID. If the session is not found, an error is raised.


==== Syntax

[source, cypher]
----
CALL gds.session.delete(
  name: String,
  projectId: String
) YIELD
  deleted: boolean
----

.Parameters
[opts="header",cols="1,1,1,1,4"]
|===
| Name       | Type      | Optional | Default | Description
| name       | String    | no       | n/a     | The name of the GDS Session to delete.
| projectId  | String    | yes      | ""      | The ID of the project to which the GDS Session belongs. If similar sessions exist in different projects an error is thrown that indicates to provide a project ID.
|===

.Results
[opts="header",cols="1,1,6"]
|===
| Name       | Type      | Description
| deleted    | Boolean   | True, if the GDS Session was successfully deleted, false otherwise.
|===


== Syntax

The GDS Session Cypher API matches the GDS plugin API as closely as possible.
Thus, most of the content in this manual applies to both products.
In general, expect to be able to use all query examples in this manual with the GDS Session Cypher API, subject to the limitations described in this section.


=== Authentication to Aura API

One key difference is the requirement for the GDS Session Cypher API to authenticate to the Aura API.
This is done by calling the `gds.aura.api.credentials()` function in each Cypher query.
An easy way to do that is to use a leading `WITH` clause in all queries.

The function does not return any value, but registers the credentials in the query context of that query.
The credentials are not persisted anywhere and will be immediately forgotten after the Cypher query has completed.

Due to this requirement, short-form `CALL`-only queries cannot be used.
See link:https://neo4j.com/docs/cypher-manual/current/clauses/call/#call-procedure-yield[the Cypher manual] for additional details.

.Calling an algorithm with only a `CALL` clause:
[source, cypher]
----
CALL gds.wcc.stream('g')
----

The above will fail with an error indicating the missing call to `gds.aura.api.credentials()`.

.Syntax
[source, cypher]
----
RETURN gds.aura.api.credentials(
  clientId: String,
  clientSecret: String
) AS credentials
----

.Configuration
[opts="header",cols="3,2,3m,2,8"]
|===
| Name         | Type   | Default | Optional | Description
| clientId     | String | n/a     | no       | The Client ID for an Aura API key pair.
| clientSecret | String | n/a     | no       | The Client Secret for an Aura API key pair.
|===

.Results
[opts="header"]
|===
| Name | Type | Description
| -    | -    | Always returns `null`.
|===


==== Examples

.Projecting a graph to a GDS Session:
[source, cypher]
----
// you can use any alias
CYPHER runtime=parallel
WITH gds.aura.api.credentials($clientId, $clientSecret) AS credentials
MATCH (n)
OPTIONAL MATCH (n)-->(m)
RETURN gds.graph.project('g', n, m, {}, {memory: '4GB'})
----

.Calling an algorithm in stream mode:
[source, cypher]
----
// you can use any alias
WITH gds.aura.api.credentials($clientId, $clientSecret) AS c
CALL gds.pageRank.stream('g')
YIELD nodeId, score // must specify YIELD
RETURN *
----


=== Projecting a graph

Use a xref:management-ops/graph-creation/graph-project-cypher-projection.adoc[Cypher projection] to project a graph into a GDS Session.
Make sure to include all the additional parameters with the `Aura Graph Analytics Serverless` label.

Use the Cypher parallel runtime to achieve the best performance during projection.

[WARNING]
Native projections and legacy Cypher projections are not supported.


=== Running algorithms

The GDS Session Cypher API supports most algorithms and machine learning operations in all existing execution modes.
The syntax is the same as for the GDS plugin, but with the additional `WITH gds.aura.api.credentials() AS credentials` clause.


==== Unsupported algorithms

Not all algorithms have been implemented in the GDS Session Cypher API.
The following algorithms are not supported:

- xref:algorithms/all-pairs-shortest-path.adoc[]
- xref:algorithms/random-walk.adoc[]
- xref:algorithms/bfs.adoc[]
- xref:algorithms/dfs.adoc[]
- xref:algorithms/bridges.adoc[]
- xref:algorithms/conductance.adoc[]
- xref:algorithms/modularity.adoc[]
- xref:algorithms/hdbscan.adoc[]
- xref:algorithms/hits.adoc[]
- xref:algorithms/dag/longest-path.adoc[]
- xref:algorithms/dag/topological-sort.adoc[]
- xref:algorithms/triangle-count.adoc#algorithms-triangle-count-examples-triangles-listing[Triangles listing]
- xref:machine-learning/node-embeddings/graph-sage.adoc[]


=== API limitations

The GDS Session Cypher API does not support all procedures and functions available in the GDS plugin.
Some that are mentioned here may be supported in the future, while others may never be supported.


==== Graph Catalog

The following Graph Catalog procedures are not supported in GDS Session Cypher API:

* `gds.graph.project`
* `gds.graph.project.estimate`
* `gds.graph.project.cypher`
* `gds.graph.project.cypher.estimate`
* `gds.graph.export`
* `gds.graph.export.csv`
* `gds.graph.export.csv.estimate`
* `gds.backup`
* `gds.restore`
* `gds.graph.graphProperty.drop`
* `gds.graph.graphProperty.stream`


==== Machine Learning

Trained models can only be used for prediction using the same session in which they were trained.
After the session is deleted, all trained models will be lost.

The following Machine Learning procedures are not supported in GDS Session Cypher API:

* `gds.model.publish`
* `gds.model.store`
* `gds.model.load`
* `gds.model.delete`
* `gds.alpha.linkprediction.adamicAdar`
* `gds.alpha.linkprediction.commonNeighbors`
* `gds.alpha.linkprediction.preferentialAttachment`
* `gds.alpha.linkprediction.resourceAllocation`
* `gds.alpha.linkprediction.sameCommunity`
* `gds.alpha.linkprediction.totalNeighbors`
* `gds.alpha.ml.splitRelationships`

Additionally, all `pipeline` procedures are unsupported.


==== Additional Operations

The following Additional Operations are not supported in GDS Session Cypher API:

* `gds.license.state`
* `gds.debug.arrow`
* `gds.debug.sysInfo`
* `gds.license.state`
* `gds.userLog`
* `gds.version`


== Examples

In this section we will illustrate how to use the GDS Session Cypher API to project a graph, run a few algorithms, and process results.


=== Projecting a graph

In order to project a graph into a GDS Session, we need to have some data in our database.

.The following Cypher statement will create the example graph in the Neo4j database:
[source, cypher, role=noplay setup-query]
----
CREATE
  (a:User {name: 'Alice', age: 23}),
  (b:User {name: 'Bridget', age: 34}),
  (c:User {name: 'Charles', age: 45}),
  (d:User {name: 'Dana', age: 56}),
  (e:User {name: 'Eve', age: 67}),
  (f:User {name: 'Fawad', age: 78}),

  (a)-[:LINK {weight: 0.5}]->(b),
  (b)-[:LINK {weight: 0.2}]->(a),
  (a)-[:LINK {weight: 4}]->(c),
  (c)-[:LINK {weight: 2}]->(e),
  (e)-[:LINK {weight: 1.1}]->(d),
  (e)-[:LINK {weight: -2}]->(f);
----

image::example-graphs/aura-graph-analytics-serverless.png[]

First, project the graph into a GDS Session, using a remote Cypher projection.
Specify the `memory` and `ttl` parameters.

.Projecting a graph called 'myGraph' using a remote Cypher projection into a new GDS Session:
[source, cypher, role=noplay setup-query]
----
CYPHER runtime=parallel
WITH gds.aura.api.credentials($clientId, $clientSecret) AS credentials
MATCH (source:User)
OPTIONAL MATCH (source)-[r:LINK]->(target:User)
WITH gds.graph.project('myGraph', source, target, {
  sourceNodeProperties: source { .age },
  targetNodeProperties: target { .age },
  relationshipProperties: r { .weight }
}, {
  memory: '4GB', ttl: duration({minutes: 5})
}) AS g
RETURN g.graphName, g.nodeCount, g.relationshipCount
----

.Results
[opts="header"]
|===
| graphName | nodeCount | relationshipCount
| 'myGraph' | 6         | 6
|===

After this completes, we now have a GDS Session with a projected graph.
If you have the Aura Console open, you should be able to see the session listed in the `Sessions` view.
Next, list the projected graph using the `gds.graph.list()` procedure.

[role=query-example]
--
.Listing the projected graph:
[source, cypher, role=noplay]
----
WITH gds.aura.api.credentials($clientId, $clientSecret) AS credentials
CALL gds.graph.list()
YIELD graphName, nodeCount, relationshipCount
RETURN graphName, nodeCount, relationshipCount
----

.Results
[opts="header"]
|===
| graphName | nodeCount | relationshipCount
| "myGraph"  | 6         | 6
|===
--


=== Running algorithms

You can run algorithms on a projected graph.
For example, run xref:algorithms/page-rank.adoc[] and xref:machine-learning/node-embeddings/fastrp.adoc[] in `mutate` mode on the example graph.
Then, `stream` the node properties and `write` them back to the AuraDB instance.

[role=query-example]
--
.Run PageRank in `mutate` mode:
[source, cypher]
----
WITH gds.aura.api.credentials($clientId, $clientSecret) AS credentials
CALL gds.pageRank.mutate('myGraph', { mutateProperty: 'pageRank' })
YIELD ranIterations, nodePropertiesWritten
RETURN ranIterations, nodePropertiesWritten
----

.Results
[opts="header"]
|===
| ranIterations | nodePropertiesWritten
| 1             | 6
|===
--

Use the mutated `pageRank` property as input to the FastRP algorithm.

[role=query-example]
--
.Run FastRP in `mutate` mode:
[source, cypher]
----
WITH gds.aura.api.credentials($clientId, $clientSecret) AS credentials
CALL gds.fastRP.mutate('myGraph', {
  featureProperties: ['pageRank'],
  relationshipWeightProperty: 'weight',
  iterationWeights: [1, 1, 1],
  randomSeed: 42,
  embeddingDimension: 8,
  mutateProperty: 'fastrp'
})
YIELD nodePropertiesWritten
RETURN nodePropertiesWritten
----

.Results
[opts="header"]
|===
| nodePropertiesWritten
| 6
|===
--

Now, stream the node properties back to the AuraDB instance.

[role=query-example]
--
.Stream node properties:
[source, cypher]
----
WITH gds.aura.api.credentials($clientId, $clientSecret) AS credentials
CALL gds.graph.nodeProperty.stream('myGraph', "fastrp")
YIELD nodeId, propertyValue
RETURN nodeId, propertyValue
ORDER BY nodeId
----

.Results
[opts="header"]
|===
| nodeId | propertyValue
| 0      | [-0.8200507164, -0.0124960952, 0.2896471024, -0.2785570323, -0.8645128608, -0.1037763357, 0.0, 0.4556654692]
| 1      | [-0.3894904256, -0.5124961138, 0.9440460801, -0.9576280117, 0.0673641935, -1.0132695436, 0.0, 0.4451318979]
| 2      | [-0.4223886132, 0.0, 0.3452976346, 0.190074876, -0.4223886132, 0.4223886132, 0.0, 0.0]
| 3      | [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
| 4      | [-0.4223886132, 0.0, -0.6547023654, 0.190074876, -0.4223886132, 0.4223886132, 0.0, 0.0]
| 5      | [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
|===
--


=== Writing results to database

It is possible to write mutated results using the `gds.graph.nodeProperty.write()` procedure.
See xref:management-ops/graph-write-to-neo4j/write-back-to-nodes.adoc[] for more details.

You can also write results directly using the `write` algorithm execution mode.

[role=query-example]
--
.Run Louvain in `write` mode:
[source, cypher]
----
WITH gds.aura.api.credentials($clientId, $clientSecret) AS credentials
CALL gds.louvain.write('myGraph', { writeProperty: 'louvain' })
YIELD communityCount, modularity
RETURN communityCount, modularity
----

.Results
[opts="header"]
|===
| communityCount | modularity
| 2              | 0.3333333333333333
|===
--



=== Cleaning up

Finally, drop the projected graph, which will also delete the GDS Session.

[role=cleanup-query]
--
.Drop the graph 'myGraph':
[source, cypher]
----
WITH gds.aura.api.credentials($clientId, $clientSecret) AS credentials
CALL gds.graph.drop('myGraph')
YIELD graphName
RETURN graphName
----

.Results
[opts="header"]
|===
| graphName
| "myGraph"
|===
--

After this completes, no more costs are incurred for the GDS Session.
You will find that the session is no longer visible in the Aura Console.
If you forget to drop the graph, the session will automatically expire after the configured `ttl` time has passed.
