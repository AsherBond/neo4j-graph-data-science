[[algorithms-node-classification-pipelines-predict]]
== Applying a trained model for prediction
:modelType: Node classification pipeline model
:entity: node

In the previous sections we have seen how to build up a Node Classification training pipeline and train it to produce a classification pipeline.
After <<algorithms-ml-nodeclassification-pipelines-train, training>>, the runnable model is of type `Node classification pipeline` and resides in the model catalog.

The classification pipeline can be executed with a graph in the graph catalog to predict the value of the `target` property (class) of previously unseen nodes.
In addition to the predicted class for each node, the predicted probability for each class may also be retained on the nodes.
The order of the probabilities matches the order of the classes registered in the model.

Since the model has been trained on features which are created using the feature pipeline, the same feature pipeline is stored within the model and executed at prediction time.
As during training, intermediate node properties created by the node property steps in the feature pipeline are transient and not visible after execution.

The predict graph must contain the properties that the pipeline requires and the used array properties must have the same dimensions as in the train graph.
If the predict and train graphs are distinct, it is also beneficial that they have similar origins and semantics, so that the model is able to generalize well.

=== Syntax

.Node Classification syntax per mode
[.tabbed-example, caption = ]
====
[.include-with-stream]
======
.Run Node Classification in stream mode on a named graph:
[source, cypher, role=noplay]
----
CALL gds.alpha.ml.pipeline.nodeClassification.predict.stream(
  graphName: String,
  configuration: Map
)
YIELD
  nodeId: Integer,
  predictedClass: Integer,
  predictedProbabilities: List of Float
----

include::../../common-configuration/common-parameters-named-graph.adoc[]

include::../../common-configuration/common-stream-stats-configuration-named-graph.adoc[]

include::specific-stream-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name                   | Type          | Description
| nodeId                 | Integer       | Node ID.
| predictedClass         | Integer       | Predicted class for this node.
| predictedProbabilities | List of Float | Probabilities for all classes, for this node.
|===
======

[.include-with-mutate]
======
.Run Node Classification in mutate mode on a named graph:
[source, cypher, role=noplay]
----
CALL gds.alpha.ml.pipeline.nodeClassification.predict.mutate(
  graphName: String,
  configuration: Map
)
YIELD
  createMillis: Integer,
  computeMillis: Integer,
  postProcessingMillis: Integer,
  mutateMillis: Integer,
  nodePropertiesWritten: Integer,
  configuration: Map
----

include::../../common-configuration/common-parameters-named-graph.adoc[]

include::../../common-configuration/common-mutate-configuration-named-graph.adoc[]

include::specific-write-mutate-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name                    | Type    | Description
| createMillis            | Integer | Milliseconds for creating the graph.
| computeMillis           | Integer | Milliseconds for running the algorithm.
| postProcessingMillis    | Integer | Milliseconds for computing the global metrics.
| mutateMillis            | Integer | Milliseconds for adding properties to the in-memory graph.
| nodePropertiesWritten    | Integer | Number of node properties written.
| configuration           | Map     | Configuration used for running the algorithm.
|===
======

[.include-with-write]
======
.Run Node Classification in write mode on a named graph:
[source, cypher, role=noplay]
----
CALL gds.alpha.ml.pipeline.nodeClassification.predict.write(
  graphName: String,
  configuration: Map
)
YIELD
  createMillis: Integer,
  computeMillis: Integer,
  postProcessingMillis: Integer,
  writeMillis: Integer,
  nodePropertiesWritten: Integer,
  configuration: Map
----

include::../../common-configuration/common-parameters-named-graph.adoc[]

include::../../common-configuration/common-write-configuration-named-graph.adoc[]

include::specific-write-mutate-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name                    | Type    | Description
| createMillis            | Integer | Milliseconds for creating the graph.
| computeMillis           | Integer | Milliseconds for running the algorithm.
| postProcessingMillis    | Integer | Milliseconds for computing the global metrics.
| writeMillis             | Integer | Milliseconds for writing result back to Neo4j.
| nodePropertiesWritten   | Integer | Number of node properties written.
| configuration           | Map     | Configuration used for running the algorithm.
|===
======

====

[[algorithms-node-classification-pipelines-predict-examples]]
=== Example
In the following examples we will show how to use a classification pipeline to predict the class of a node in your in-memory graph.
In addition to the predicted class, we will also produce the probability for each class in another node property.
In order to do this, we must first have an already trained model registered in the Model Catalog.
We will use the model which we trained in the <<algorithms-ml-nodeclassification-pipelines-train, train example>> which we gave the name `'nc-pipeline-model'`.

[[algorithms-node-classification-pipelines-predict-examples-stream]]
==== Stream
[role=query-example, group=nc]
--
[source, cypher]
----
CALL gds.alpha.ml.pipeline.nodeClassification.predict.stream('myGraph', {
  modelName: 'nc-pipeline-model',
  includePredictedProbabilities: true,
  nodeLabels: ['UnknownHouse']
})
 YIELD nodeId, predictedClass, predictedProbabilities
WITH gds.util.asNode(nodeId) AS houseNode, predictedClass, predictedProbabilities
RETURN
  houseNode.color AS classifiedHouse,
  predictedClass,
  floor(predictedProbabilities[predictedClass] * 100) AS confidence
  ORDER BY classifiedHouse
----

.Results
[opts="header",cols="m,m,m"]
|===
| classifiedHouse | predictedClass | confidence
| "Pink"          |              0 | 98.0
| "Tan"           |              1 | 98.0
| "Yellow"        |              2 | 79.0
|===

As we can see, the model was able to predict the pink house into class 0, tan house into class 1, and yellow house into class 2.
This makes sense, as all houses in class 0 had three stories, class 1 two stories and class 2 one story, and the same is true of the pink, tan and yellow houses, respectively.
Additionally, we see that the model is confident in these predictions, as the highest class probability is >=80% in all cases.
--

[[algorithms-ml-nodeclassification-pipeline-examples-mutate]]
==== Mutate

The `mutate` execution mode updates the named graph with a new node property containing the predicted class for that node.
The name of the new property is specified using the mandatory configuration parameter `mutateProperty`.
The result is a single summary row including information about timings and how many properties were written.
The `mutate` mode is especially useful when multiple algorithms are used in conjunction.

For more details on the `mutate` mode in general, see <<running-algos-mutate>>.

[role=query-example, group=nc]
--
[source, cypher, role=noplay]
----
CALL gds.alpha.ml.pipeline.nodeClassification.predict.mutate('myGraph', {
  nodeLabels: ['UnknownHouse'],
  modelName: 'nc-pipeline-model',
  mutateProperty: 'predictedClass',
  predictedProbabilityProperty: 'predictedProbabilities'
}) YIELD nodePropertiesWritten
----

.Results
[opts="header"]
|===
| nodePropertiesWritten
| 6
|===
--


Since we specified also the `predictedProbabilityProperty` we are writing two properties for each of the 14 nodes.
In order to analyse our predicted classes we stream the properties from the in-memory graph:

[role=query-example, no-result=true, group=nc]
--
[source, cypher, role=noplay]
----
CALL gds.graph.streamNodeProperties(
  'myGraph', ['predictedProbabilities', 'predictedClass'], ['UnknownHouse']
) YIELD nodeId, nodeProperty, propertyValue
RETURN gds.util.asNode(nodeId).color AS classifiedHouse, nodeProperty, propertyValue
  ORDER BY classifiedHouse, nodeProperty
----

.Results
[opts="header"]
|===
| classifiedHouse | nodeProperty             | propertyValue
| "Pink"          | "predictedClass"         | 0
| "Pink"          | "predictedProbabilities" | [0.9866455686217779, 0.01311656378786989, 2.3786759035214687E-4]
| "Tan"           | "predictedClass"         | 1
| "Tan"           | "predictedProbabilities" | [0.01749164563726576, 0.9824922482993587, 1.610606337562594E-5]
| "Yellow"        | "predictedClass"         | 2
| "Yellow"        | "predictedProbabilities" | [0.0385634113659007, 0.16350471177895198, 0.7979318768551473]
|===
--

As we can see, the model was able to predict the pink house into class 0, tan house into class 1, and yellow house into class 2.
This makes sense, as all houses in class 0 had three stories, class 1 two stories and class 2 one story, and the same is true of the pink, tan and yellow houses, respectively.
Additionally, we see that the model is confident in these predictions, as the highest class probability is >75% in all cases.


[[algorithms-ml-nodeclassification-pipeline-examples-write]]
==== Write

The `write` execution mode writes the predicted property for each node as a property to the Neo4j database.
The name of the new property is specified using the mandatory configuration parameter `writeProperty`.
The result is a single summary row including information about timings and how many properties were written.
The `write` mode enables directly persisting the results to the database.

For more details on the `write` mode in general, see <<running-algos-write>>.

[role=query-example, group=nc]
--
[source, cypher, role=noplay]
----
CALL gds.alpha.ml.pipeline.nodeClassification.predict.write('myGraph', {
  nodeLabels: ['UnknownHouse'],
  modelName: 'nc-pipeline-model',
  writeProperty: 'predictedClass',
  predictedProbabilityProperty: 'predictedProbabilities'
}) YIELD nodePropertiesWritten
----

.Results
[opts="header"]
|===
| nodePropertiesWritten
| 6
|===
--

Since we specified also the `predictedProbabilityProperty` we are writing two properties for each of the 14 nodes.
In order to analyse our predicted classes we stream the properties from the in-memory graph:

[role=query-example, no-result=true, group=nc]
--
[source, cypher, role=noplay]
----
MATCH (house:UnknownHouse)
RETURN house.color AS classifiedHouse, house.predictedClass AS predictedClass, house.predictedProbabilities AS predictedProbabilities
----

.Results
[opts="header"]
|===
| classifiedHouse | predictedClass | predictedProbabilities
| "Pink"          |              0 | [0.9866455686217779, 0.01311656378786989, 2.3786759035214687E-4]
| "Tan"           |              1 | [0.01749164563726576, 0.9824922482993587, 1.610606337562594E-5]
| "Yellow"        |              2 | [0.0385634113659007, 0.16350471177895198, 0.7979318768551473]
|===
--


As we can see, the model was able to predict the pink house into class 0, tan house into class 1, and yellow house into class 2.
This makes sense, as all houses in class 0 had three stories, class 1 two stories and class 2 one story, and the same is true of the pink, tan and yellow houses, respectively.
Additionally, we see that the model is confident in these predictions, as the highest class probability is >75% in all cases.
